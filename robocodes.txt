package org.usfirst.frc.team4152.robot;

import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SampleRobot;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.Talon;

/**
 * This is a demo program showing the use of the RobotDrive class. The
 * SampleRobot class is the base of a robot application that will automatically
 * call your Autonomous and OperatorControl methods at the right time as
 * controlled by the switches on the driver station or the field controls.
 *
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the SampleRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 *
 * WARNING: While it may look like a good choice to use for your code if you're
 * inexperienced, don't. Unless you know what you are doing, complex code will
 * be much more difficult under this system. Use IterativeRobot or Command-Based
 * instead if you're new.
 */
public class Robot extends SampleRobot {
	
	////RobotDrive System////
							//front left, back left, front right, back right.
	RobotDrive myRobot = new RobotDrive(0,1);
	Joystick stick = new Joystick(0);
	Joystick rightStick = new Joystick(1);
	//driving modes
	final boolean arcadeDrive = false;
	final boolean tankDrive = true;
	
	////DriveAccel Variables////
	double driveAccelMultiIncrease = 0.15;
	double driveAccelMultiInit = 0.4;
	double driveAccelMulti = driveAccelMultiInit;
	Timer driveTimeAccel = new Timer();
	
	////DumpLoad System////
	DigitalInput SwitchDumpAxisExceed = new DigitalInput(5);
	DigitalInput SwitchHoldAxisExceed = new DigitalInput(6);
	Spark dumpMotor = new Spark(10);
	Spark loadingMotor = new Spark(7);
	
	////CLIMB////
	Talon climbMotor = new Talon(5);
	
	//stores button values in memory, makes the code easier to understand
    final int buttonA = 1;
    final int buttonB = 2;
    final int buttonX = 3;
    final int buttonY = 4;
    final int leftBumper = 5;
    final int rightBumper = 6;
    final int buttonBack = 7;
    final int buttonStart = 8;
    final int lsPush = 9;
    final int rsPush = 10;
    
    ////Encoder Values////
	Encoder leftEncoder = new Encoder(1, 0, false);
	Encoder rightEncoder = new Encoder(4, 3 , false);
    final double wheelCircumference = 6 * Math.PI;

	public Robot() {
		myRobot.setExpiration(0.1);
	}

	@Override
	public void robotInit() {
	}

	/**
	 * This autonomous (along with the chooser code above) shows how to select
	 * between different autonomous modes using the dashboard. The sendable
	 * chooser code works with the Java SmartDashboard. If you prefer the
	 * LabVIEW Dashboard, remove all of the chooser code and uncomment the
	 * getString line to get the auto name from the text box below the Gyro
	 *
	 * You can add additional auto modes by adding additional comparisons to the
	 * if-else structure below with additional strings. If using the
	 * SendableChooser make sure to add them to the chooser code above as well.
	 */
	@Override
	public void autonomous() {
		drive(120);
	}

	/**
	 * Runs the motors with arcade steering.
	 */
	@Override
	public void operatorControl() {
		leftEncoder.setDistancePerPulse(wheelCircumference/2036);
		rightEncoder.setDistancePerPulse(wheelCircumference/2036);
		myRobot.setSafetyEnabled(true);
		driveTimeAccel.start();
		leftEncoder.reset();
		rightEncoder.reset();
		while (isOperatorControl() && isEnabled()) {
			SmartDashboard.putBoolean("BoolTest", true);
			SmartDashboard.putInt("OpticEncoder", leftEncoder.get());
			SmartDashboard.putDouble("distance driven left wheels", leftEncoder.getDistance()*-1);
			SmartDashboard.putDouble("distance driven right wheels", rightEncoder.getDistance());
			//Move Value, Rotate value
			if(arcadeDrive) myRobot.arcadeDrive(stick.getRawAxis(1) * driveAccelMulti, stick.getRawAxis(0) * -driveAccelMulti);
			if(tankDrive) myRobot.tankDrive(stick.getRawAxis(1), rightStick.getRawAxis(1));
			driveAccel();
			DumpBalls();
			loadingSystem();
			climbSystem();
			Timer.delay(0.005); // wait for a motor update time
		}
	}
	
	public void climbSystem()
	{
		if(stick.getRawButton(buttonStart) && stick.getRawButton(buttonBack))
		{
			climbMotor.set(1);
		}
		else
		{
			climbMotor.set(0);
		}
	}
	
	public void DumpBalls()
	{
		if(stick.getRawButton(buttonX) && SwitchDumpAxisExceed.get() == false)
		{
			dumpMotor.set(0.5);
		} 
		else if(stick.getRawButton(buttonY) && SwitchHoldAxisExceed.get() == false)
		{
			dumpMotor.set(-0.5);
		}
		else
		{
			dumpMotor.set(0);
		}
	}
	
	double loadingPower = 0;
	
	public void loadingSystem()
	{
		SmartDashboard.putDouble("LOAD POWAR", loadingPower);
		if(stick.getRawButton(rightBumper))
		{
			loadingMotor.set(loadingPower);
		}
		else
		{
			loadingMotor.set(0);
		}
		if(stick.getRawButton(buttonB) && loadingPower > -0.9)
		{
			loadingPower += -0.1;
			Timer.delay(0.2);
		}
		else if(stick.getRawButton(buttonX) && loadingPower < 0.9)
		{
			loadingPower += 0.1;
			Timer.delay(0.2);
		}
	}
	
	public void driveAccel()
	{
		SmartDashboard.putDouble("Axis0", stick.getRawAxis(0));
		SmartDashboard.putDouble("Axis1", stick.getRawAxis(1));
		SmartDashboard.putDouble("DriveMulti", driveAccelMulti);
		//checks if axis 0 exceeds range of 0.1 in either direction, then same for axis 1. After those checks it checks the timer to see if it exceeds 0.1 seconds. Axis 0 and Axis 1 exist as an OR due to one being able to equal 0 and one equal 1 or -1. Timer is an AND due to it being required during check to not jump up by a delay of 0.005.
		if((stick.getRawAxis(0) < -0.1 || stick.getRawAxis(0) > 0.1) || (stick.getRawAxis(1) < -0.1 || stick.getRawAxis(1) > 0.1))
		{
			if(driveAccelMulti < 0.9 && driveTimeAccel.get() > 0.075)
			{
				driveAccelMulti += driveAccelMultiIncrease;
				driveTimeAccel.reset();
			}
		}
		else
		{
			driveAccelMulti = driveAccelMultiInit;
		}
	}
	
	//Distance in inches
	public void drive(double distance){
		drive(distance, 1);
	}
	
	public void drive(double distance, double speed){
		leftEncoder.reset();
		while(Math.abs(leftEncoder.getDistance())<distance)
		{
			myRobot.arcadeDrive(speed, 0);
		}
		SmartDashboard.putDouble("distance driven left wheels", leftEncoder.getDistance()*-1);
		SmartDashboard.putDouble("distance driven right wheels", rightEncoder.getDistance());
	}
	
	final double pivotCircumference = 81.64;
	final double pivotDegree = pivotCircumference / 360;
	
	public void turnRight(double degrees){
		double pivotDegrees = pivotDegree * degrees;
		while(Math.abs(leftEncoder.getDistance()) < pivotDegrees){
			myRobot.tankDrive(1, 0);
		}
	}

	public void turnLeft(double degrees){
		double pivotDegrees = pivotDegree * degrees;
		while(Math.abs(rightEncoder.getDistance()) < pivotDegrees){
			myRobot.tankDrive(0, 1);
		}
	}
	
	/*public void pivotRight(){
		leftEncoder.reset();
		while(Math.abs(leftEncoder.getDistance()) < 24.4){
			myRobot.tankDrive(1, 0);
		}
	}
	
	public void pivotLeft(){
		rightEncoder.reset();
		while(Math.abs(rightEncoder.getDistance()) < 24.4){
			myRobot.tankDrive(0, 1);
		}
	}*/
	
	/**
	 * Runs during test mode
	 */
	@Override
	public void test() {
	}
}