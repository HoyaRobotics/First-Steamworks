package org.usfirst.frc.team4152.robot;

import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SampleRobot;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.Talon;

public class Robot extends SampleRobot{
	
	////RobotDrive System////
	                        //front left, back left, front right, back right
	RobotDrive myRobot = new RobotDrive(0, 1);
	Joystick stick = new Joystick(0);
	Joystick rightStick = new Joystick(1);
	//Driving Modes
	final boolean arcadeDrive = true;
	final boolean tankDrive = false;
	
	////DriveAccel Variables////
	double driveAccelMultiIncrease = 0.15;
	double driveAccelMultiInit = 0.4;
	double driveAccelMulti = driveAccelMultiInit;
	Timer driveTimeAccel = new Timer();
	
	////Ball Dump/Load System////
	DigitalInput switchDumpAxisExceed = new DigitalInput(5);
	DigitalInput switchHoldAxisExceed = new DigitalInput(6);
	Spark dumpMotor = new Spark(4);
	Talon loadMotor = new Talon(2);
	
	////Climb System////
	Talon climbMotor = new Talon(5);
	boolean climbing = false;
	Timer teleOpTime = new Timer();
	
	////Button Values////
	final int buttonA = 1;
	final int buttonB = 2;
	final int buttonX = 3;
	final int buttonY = 4;
	final int leftBumper = 5;
	final int rightBumper = 6;
	final int buttonBack = 7;
	final int buttonStart = 8;
	final int lsPush = 9;
	final int rsPush = 10;
	
	////Encoder Variables////
	Encoder leftEncoder = new Encoder(1, 0, false);
	Encoder rightEncoder = new Encoder(4, 3, false);
	final double wheelCircumference = 6 * Math.PI;
	
	//Constructor called when robot initialized
	public Robot(){
		myRobot.setExpiration(0.1);
	}
	
	@Override
	public void robotInit(){ }
	@Override
	public void test(){ }
	
	//Method called during autonomous mode
	@Override
	public void autonomous(){
		leftEncoder.setDistancePerPulse(wheelCircumference/2036);
		rightEncoder.setDistancePerPulse(wheelCircumference/2036);
		//drive(60);
		//turnRightVariableSpeed(90);
	}
	
	//Method called during tele-operated mode
	@Override
	public void operatorControl(){
		double speedController = stick.getRawAxis(2);
		leftEncoder.setDistancePerPulse(wheelCircumference/2036);
		rightEncoder.setDistancePerPulse(wheelCircumference/2036);
		myRobot.setSafetyEnabled(true);
		driveTimeAccel.start();
		teleOpTime.start();
		leftEncoder.reset();
		rightEncoder.reset();
		while(isOperatorControl() && isEnabled()){
			speedController = stick.getRawAxis(2);
			
			//Values displayed on the Smart Dashboard
			SmartDashboard.putBoolean("BoolTest", true);
			SmartDashboard.putInt("OpticEncoder", leftEncoder.get());
			SmartDashboard.putDouble("Distance driven left wheels", leftEncoder.getDistance() * -1);
			SmartDashboard.putDouble("Distance driven right wheels", rightEncoder.getDistance());
			SmartDashboard.putDouble("SpeedController", speedController * 100);
			
			//Move value, rotate value
			if(arcadeDrive && !climbing) myRobot.arcadeDrive(stick.getRawAxis(1) * driveAccelMulti * speedController, stick.getRawAxis(0) * -driveAccelMulti * speedController);
			if(tankDrive) myRobot.tankDrive(stick.getRawAxis(1), rightStick.getRawAxis(1));
			
			//Robot function calls
			driveAccel();
			dumpBalls();
			loadSystem();
			climbSystem();
			
			Timer.delay(0.005); //Wait for a motor update time
		}
	}
	
	public void climbSystem(){
		//if(matchTime.get() >= 105){
			if(stick.getRawButton(rsPush) && stick.getRawButton(lsPush)){
				climbMotor.set(1);
				climbing = true;
				SmartDashboard.putBoolean("Climbing", true);
			}else{
				climbMotor.set(0);
				climbing = false;
				SmartDashboard.putBoolean("Climbing", false);
			}
		//}
	}
	
	public void dumpBalls(){
		if(stick.getRawButton(buttonY)){
			dumpMotor.set(0.6);
		}else if(stick.getRawButton(buttonA)){
			dumpMotor.set(-0.4);
		}else{
			dumpMotor.set(0);
		}
	}
	
	double loadPower = 0;
	
	public void loadSystem(){
		SmartDashboard.putDouble("Load Power", loadPower);
		
		if(stick.getRawButton(rightBumper)){
			loadMotor.set(-1);
		}else if(stick.getRawButton(leftBumper)){
			loadMotor.set(1);
		}else{
			loadMotor.set(0);
		}
	}
	
	public void driveAccel(){
		SmartDashboard.putDouble("Axis0", stick.getRawAxis(0));
		SmartDashboard.putDouble("Axis1", stick.getRawAxis(1));
		SmartDashboard.putDouble("DriveMulti", driveAccelMulti);
		
		//Checks if axis 0 exceeds range of 0.1 in either direction, then same for axis 1.
		//After those checks it checks the timer to see if it exceeds 0.1 seconds. Axis 0
		//and Axis 1 exist as an OR due to one being able to equal 0 and one equal 1 or -1.
		//Timer is an AND due to it being required during check to not jump up by a delay
		//of 0.005.
		if(Math.abs(stick.getRawAxis(0)) > 0.1 || Math.abs(stick.getRawAxis(1)) > 0.1){
			if(driveAccelMulti < 0.9 && driveTimeAccel.get() > 0.075){
				driveAccelMulti += driveAccelMultiIncrease;
				driveTimeAccel.reset();
			}
		}else{
			driveAccelMulti = driveAccelMultiInit;
		}
	}
	
	//Distance in inches
	public void drive(double distance){
		drive(distance, -1);
	}
	
	public void drive(double distance, double speed){
		leftEncoder.reset();
		while(Math.abs(leftEncoder.getDistance()) < distance){
			myRobot.arcadeDrive(speed, 0);
		}
		
		SmartDashboard.putDouble("Distance driven left wheels", leftEncoder.getDistance());
		SmartDashboard.putDouble("Distance driven right wheels", rightEncoder.getDistance());
		
		double lastDistance = leftEncoder.getDistance();
		while((Math.abs(leftEncoder.getDistance()) - lastDistance) >= 0.75){
			myRobot.arcadeDrive(1, 0);
			lastDistance = Math.abs(leftEncoder.getDistance());
		}
	}
	
	final double pivotCircumference = 24.4 * Math.PI;
	final double pivotDegree = pivotCircumference / 360;
	
	public void turnRight(double degrees){
		leftEncoder.reset();
		double pivotDegrees = pivotDegree * degrees;
		while(Math.abs(leftEncoder.getDistance()) < pivotDegrees){
			myRobot.arcadeDrive(0, -1);
		}
		double lastDistance = leftEncoder.getDistance();
		while((Math.abs(leftEncoder.getDistance()) - lastDistance) >= 0.75){
			myRobot.arcadeDrive(0, 1);
			lastDistance = Math.abs(leftEncoder.getDistance());
		}
		//myRobot.arcadeDrive(0, 1);
	}
	
	public void turnRightVariableSpeed(double degrees){
		leftEncoder.reset();
		double pivotDegrees = pivotDegree * degrees;
		double percentage = leftEncoder.getDistance() / pivotDegrees;
		while(Math.abs(leftEncoder.getDistance()) < pivotDegrees){
			if(percentage > 0.5){
				myRobot.arcadeDrive(0, -1);
			}else if(percentage > 0.1){
				myRobot.arcadeDrive(0, -0.75);
			}else{
				myRobot.arcadeDrive(0, -0.5);
			}
		}
	}
	
	public void turnLeft(double degrees){
		rightEncoder.reset();
		double pivotDegrees = pivotDegree * degrees;
		while(Math.abs(rightEncoder.getDistance()) < pivotDegrees){
			myRobot.arcadeDrive(0, 1);
		}
		double lastDistance = rightEncoder.getDistance();
		while((Math.abs(rightEncoder.getDistance()) - lastDistance) >= 0.75){
			myRobot.arcadeDrive(0, -1);
			lastDistance = Math.abs(rightEncoder.getDistance());
		}
		//myRobot.arcadeDrive(0, -1);
	}
}